// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: queue_skills.sql

package sqlc

import (
	"context"
)

const deleteQueueSkill = `-- name: DeleteQueueSkill :exec
DELETE FROM queue_skills
WHERE queue_id = $1
    AND skill_id = $2
`

type DeleteQueueSkillParams struct {
	QueueID string
	SkillID string
}

func (q *Queries) DeleteQueueSkill(ctx context.Context, arg DeleteQueueSkillParams) error {
	_, err := q.db.Exec(ctx, deleteQueueSkill, arg.QueueID, arg.SkillID)
	return err
}

const getQueueSkill = `-- name: GetQueueSkill :one
SELECT
    s.id,
    s.name,
    qs.level,
    qs.choice
FROM
    queue_skills qs
    JOIN skills s ON s.id = qs.skill_id
WHERE
    qs.queue_id = $1
    AND s.id = $2
`

type GetQueueSkillParams struct {
	QueueID string
	ID      string
}

type GetQueueSkillRow struct {
	ID     string
	Name   string
	Level  int32
	Choice int32
}

func (q *Queries) GetQueueSkill(ctx context.Context, arg GetQueueSkillParams) (GetQueueSkillRow, error) {
	row := q.db.QueryRow(ctx, getQueueSkill, arg.QueueID, arg.ID)
	var i GetQueueSkillRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Level,
		&i.Choice,
	)
	return i, err
}

const getQueueSkills = `-- name: GetQueueSkills :many
SELECT
    s.id,
    s.name,
    qs.level,
    qs.choice
FROM
    queue_skills qs
    JOIN skills s ON s.id = qs.skill_id
WHERE
    qs.queue_id = $1
`

type GetQueueSkillsRow struct {
	ID     string
	Name   string
	Level  int32
	Choice int32
}

func (q *Queries) GetQueueSkills(ctx context.Context, queueID string) ([]GetQueueSkillsRow, error) {
	rows, err := q.db.Query(ctx, getQueueSkills, queueID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetQueueSkillsRow
	for rows.Next() {
		var i GetQueueSkillsRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Level,
			&i.Choice,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const upsertQueueSkill = `-- name: UpsertQueueSkill :one
WITH upserted AS (
INSERT INTO queue_skills(queue_id, skill_id, level, choice)
        VALUES ($1, $2, $3, $4)
    ON CONFLICT (queue_id, skill_id)
        DO UPDATE SET level = EXCLUDED.level, choice = EXCLUDED.choice
    RETURNING
        skill_id, level, choice)
        SELECT
            u.skill_id AS id,
            s.name AS name,
            u.level AS level,
            u.choice AS choice
        FROM
            upserted u
            JOIN skills s ON s.id = u.skill_id
`

type UpsertQueueSkillParams struct {
	QueueID string
	SkillID string
	Level   int32
	Choice  int32
}

type UpsertQueueSkillRow struct {
	ID     string
	Name   string
	Level  int32
	Choice int32
}

func (q *Queries) UpsertQueueSkill(ctx context.Context, arg UpsertQueueSkillParams) (UpsertQueueSkillRow, error) {
	row := q.db.QueryRow(ctx, upsertQueueSkill,
		arg.QueueID,
		arg.SkillID,
		arg.Level,
		arg.Choice,
	)
	var i UpsertQueueSkillRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Level,
		&i.Choice,
	)
	return i, err
}
